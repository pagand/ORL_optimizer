# -*- coding: utf-8 -*-
"""VesselEnvironment_NewUI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1biWfQoVp-Kt0yYpcJ-Lg6yh4wObyVhSC
"""

import os
import pickle
import random
import gym
import pandas as pd
import numpy as np
import torch
import torch.nn as nn
from sklearn.preprocessing import MinMaxScaler
from transformers import InformerForPrediction, InformerConfig
import tkinter as tk
from tkinter import *
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg


import sys
import io
import time
import csv
import math
from PIL import Image
from PIL.ImageQt import ImageQt
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import pyqtSignal, QPoint, Qt, QTimer
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QLineEdit, QMainWindow, QGridLayout, QFrame, QSizePolicy, QSlider
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas


import sys
from PyQt5.QtWidgets import (
    QApplication,
    QMainWindow,
    QLabel,
    QVBoxLayout,
    QHBoxLayout,
    QLineEdit,
    QSlider,
    QComboBox,
    QProgressBar,
    QWidget,
    QFrame,
    QTableWidget,
    QTableWidgetItem
)
from PyQt5.QtGui import QPixmap
from PyQt5.QtCore import Qt

'''
import psycopg2
from datetime import datetime

db_params = {
    "dbname": "beambox_prod",
    "user": "sfu",
    "password": "q4HE9RTmandaYHCHiGQh5nTR",
    "host": "127.0.0.1",
    "port": "5432"
}

try:
    conn = psycopg2.connect(**db_params)
    cursor = conn.cursor()

    cursor.execute("""
            SELECT *
            FROM signals
            ORDER BY recorded_at DESC
            LIMIT 1;
          """)
    rows = cursor.fetchone()

    if row:
        recorded_at = row[0]

        if isinstance(recorded_at, datetime):
            year = recorded_at.year
            month = recorded_at.month
            day = recorded_at.day
            hour = recorded_at.hour
            minute = recorded_at.minute
        else:
            print("Invalid Timestamp")
    else:
        print("No Data Found")

except Exception as e:
    print(f"An error occurred: {e}")

finally:
    if cursor:
        cursor.close()
    if conn:
        conn.close()
    print("Database Closed")
'''

class GRU_update(nn.Module):
    def __init__(self, input_size, hidden_size=1, output_size=4, num_layers=1, prediction_horizon=5, device="cpu"):
        super().__init__()
        self.device = device
        self.h = prediction_horizon
        self.hidden_size = hidden_size
        self.output_size = output_size
        self.gru = nn.GRU(input_size, hidden_size, num_layers, batch_first=True)
        self.mlp = nn.Sequential( nn.ReLU(),
                                  nn.Linear(hidden_size, 2048),
                                  nn.Dropout(0.2),
                                  nn.ReLU(),
                                  nn.Linear(2048, output_size))
        self.hx_fc = nn.Linear(2*hidden_size, hidden_size)

    def forward(self, predicted_values, past_time_features):
        xy = torch.zeros(size=(past_time_features.shape[0], 1, self.output_size)).float().to(self.device)
        hx = past_time_features.reshape(-1, 1, self.hidden_size)
        hx = hx.permute(1, 0, 2)
        out_wp = list()
        for i in range(self.h):
            ins = torch.cat([xy, predicted_values[:, i:i+1, :]], dim=1) # x
            hx, _ = self.gru(ins, hx.contiguous())
            hx = hx.reshape(-1, 2*self.hidden_size)
            hx = self.hx_fc(hx)
            d_xy = self.mlp(hx).reshape(-1, 1, self.output_size) #control v4
            hx = hx.reshape(1, -1, self.hidden_size)
            # print("dxy", d_xy)
            xy = xy + d_xy
            # print("xy plused", xy)
            out_wp.append(xy)
        pred_wp = torch.stack(out_wp, dim=1).squeeze(2)
        return pred_wp

class VesselEnvironment(gym.Env):
    """An environment for OpenAI gym"""
    metadata = {'render.modes': ['human']}
    # model = [tf_loc, gru_loc, tf_fc, gru_fc]
    def __init__(self, rl_data, scaler, toptrips, models_file_path, reward_type = "mimic"):

        self.rl_data = rl_data
        self.manual = False
        self.run = False
        self.done =False
        self.scale_var = False
        self.max_steps = 124
        self.trip_id = 0
        self.reward_type = reward_type
        # load best 1% trips to calculate reward1
        self.hn_top = toptrips[0]
        self.nh_top = toptrips[1]
        # set scaler
        self.scaler = scaler
        # get device
        if torch.cuda.is_available():
            self.device = torch.device('cuda:0')
        else:
            self.device = torch.device('cpu')
        # load forecasting models
        self._load_model(models_file_path)
        self._set_eval()

        self.status = "Stopped"
        self.cmp_dial = None
        self.thr_gauge = None
        self.sfc_plot = None
        self.info_panel = None
        self.num_pad = None
        self.speed_var = 0.5
        self.heading_var = 0.5
        self.mode_var = 0
        self.eta_var = '00:00'
        self.total_sec = 0

        self.left_layout = None
        self.center_layout = None
        self.right_layout = None

    def _load_model(self, file_path):
        # load transformer for longitude latitude prediction
        config_loc = InformerConfig.from_pretrained("huggingface/informer-tourism-monthly",
                prediction_length=5, context_length=24, input_size=2, num_time_features=1,
                num_dynamic_real_features = 16, num_static_real_features = 4,
                lags_sequence=[1], num_static_categorical_features=0, feature_size=27)
        self.tf_loc = InformerForPrediction(config_loc).to(self.device)
        self.tf_loc.load_state_dict(torch.load(file_path[0],
                map_location=torch.device(self.device)))

        # load transformer for fc sog prediction
        config_fc = InformerConfig.from_pretrained("huggingface/informer-tourism-monthly",
                prediction_length=5, context_length=24, input_size=2, num_time_features=1,
                num_dynamic_real_features = 11, num_static_real_features = 4,
                lags_sequence=[1], num_static_categorical_features=0, feature_size=22)
        self.tf_fc = InformerForPrediction(config_fc).to(self.device)
        self.tf_fc.load_state_dict(torch.load(file_path[1],
                map_location=torch.device(self.device)))

        # load gru models
        self.gru_loc = GRU_update(2, hidden_size=425, output_size=2, num_layers=1, prediction_horizon=5, device=self.device).to(self.device)
        self.gru_fc = GRU_update(2, hidden_size=300, output_size=2, num_layers=1, prediction_horizon=5, device=self.device).to(self.device)
        self.gru_loc.load_state_dict(torch.load(file_path[2],
                map_location=torch.device(self.device)))
        self.gru_fc.load_state_dict(torch.load(file_path[3],
                map_location=torch.device(self.device)))

    # set to models eval mode
    def _set_eval(self):
        self.gru_fc.eval()
        self.gru_loc.eval()
        self.tf_fc.eval()
        self.tf_loc.eval()

        # initialize values
        self.current_step = 25
        self.reward_cum = 0
        self.reward = 0
        self.obs = np.zeros([1,19], dtype=np.float64)
        self.actions = np.zeros([1,3], dtype=np.float64)

    def _get_observation(self):
        return self.obs[-25:]

    def reset(self, seed=None):
        # We need the following line to seed self.np_random
        super().reset(seed=seed)
        if(self.trip_id < len(self.rl_data)-1):
            self.trip_id = self.trip_id + 1
        else:
            self.trip_id = 1

        self.data = self.rl_data[self.trip_id]["observations"]
        self.current_step = 25
        self.obs = self.rl_data[self.trip_id]["observations"][0:25]
        self.actions = self.rl_data[self.trip_id]["actions"][0:25]

        # get direction and other static features
        self.direction = self.rl_data[self.trip_id]["observations"][0, 13]
        self.statics = self.rl_data[self.trip_id]["observations"][0, 12:16]
        if self.direction==1:
            self.top1 = self.hn_top
            self.goal_long, self.goal_lat = np.float64(0.9965111208024382), np.float64(0.7729570345408661)
        else:
            self.top1 = self.nh_top
            self.goal_long, self.goal_lat = np.float64(0.0023259194650222526), np.float64(0)

        # calculate the cumulative reward
        self.reward_cum = 0

        return self._get_observation(), {}

    def _take_action(self, action):
        # get actions
        speed, heading, mode = action
        mode = int(mode>0.5)
        if self.current_step < self.rl_data[self.trip_id]["observations"].shape[0]:
            future_obs = self.rl_data[self.trip_id]["observations"][self.current_step].copy()
        else:
            future_obs = self.rl_data[self.trip_id]["observations"][-1].copy()
        obs = self._get_observation().copy()

        actions = self.actions[-25:].copy()

        # obs_cols = [0"Time2", 1"turn", 2"acceleration", 3"distance",
        #    4'current', 5'rain', 6'snowfall',7 'wind_force',8 'wind_direc', 9"resist_ratio",
        #   '10change_x_factor', '11change_y_factor',
        #    12"is_weekday",13 'direction', 14"season",15"hour",
        #    16"FC", 17"SOG", 18"LATITUDE", 19'LONGITUDE',
        #    ],
        # action_cols = ["SPEED", "HEADING", "MODE"]
        # time_feature = ["Time2", "SPEED", "HEADING", "MODE", "turn", "acceleration",
        #     "distance", 'current', 'rain', 'snowfall', 'wind_force', 'wind_direc', "resist_ratio",
        #     "FC", "SOG"]
        # static_categorical_feature = ["is_weekday", 'direction',"season", "hour"]
        # y_cols = ["FC2", "SOG4"]
        # dynamic_real_feature = [["Time2", "SPEED", "HEADING", "MODE", "turn", "acceleration",
        #     "change_x_factor", "change_y_factor",
        #     "distance", 'current', 'rain', 'snowfall', 'wind_force', 'wind_direc', "resist_ratio"]

        # index of features only used in the fc model e.g.
        fc_feature_index = [0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12]

        # get model inputs
        past_time_features = np.zeros([25, 17])
        past_time_features[:, 0] = obs[:, 0]
        past_time_features[:, 1:4] = actions[:] # speed, heading, mode
        past_time_features[:, 4:15] = obs[:, 1:12]
        past_time_features[:, -2:] = obs[:, 16:18]**2

        future_time_features = past_time_features[-5:].copy()
        future_time_features[:, 0] = future_time_features[:, 0] + 5/120
        future_time_features[0, [1,2,3]] = speed, heading, mode
        future_time_features[0, 4] = heading - past_time_features[-1, 2]
        change_x = np.cos((heading+90) * np.pi / 180)
        change_y = np.sin((heading-90) * np.pi / 180)
        future_time_features[0, [13,14]] = change_x, change_y

        past_values = obs[:, -2:].copy()

        # predict fc, sog, long, lat
        fc2, sog2 = self._predict(past_time_features[:, 15:17], past_time_features[:,fc_feature_index],
                                  future_time_features[:, fc_feature_index], self.tf_fc, self.gru_fc)
        lat, long = self._predict(past_values, past_time_features, future_time_features,
                                  self.tf_loc, self.gru_loc)
        fc, sog = min(1, max(0, fc2)**0.5), min(1, max(0, sog2)**0.5)

        # generate next observation and update obs list
        new_observe = future_obs
        new_observe[0] = future_time_features[0, 0]
        new_observe[1:3] = future_time_features[0, 4:6]
        distance = ((self.goal_long-long)**2 + (self.goal_lat-lat)**2 )**0.5
        new_observe[3] = distance
        new_observe[-4:] = fc, sog, lat, long
        # new_observe[-4:] = future_obs[16:19]

        # append new observations and actions
        self.obs = np.append(self.obs, np.expand_dims(new_observe, 0), axis=0)
        self.actions = np.append(self.actions, np.expand_dims(action, 0), axis=0)

        return fc ,sog, lat, long

    def _predict(self, past_values, past_time_features, future_time_features, tf_model, gru_model):
        future_time_features = torch.from_numpy(np.expand_dims(future_time_features, 0)).float().to(self.device)
        past_values = torch.from_numpy(np.expand_dims(past_values, 0)).float().to(self.device)
        past_time_features = torch.from_numpy(np.expand_dims(past_time_features, 0)).float().to(self.device)
        static_real_features = torch.from_numpy(np.expand_dims(self.statics, 0)).float().to(self.device)
        past_observed_mask = torch.ones(past_values.shape).to(self.device)

        # print(past_values.shape, past_time_features.shape, future_time_features.shape)
        # make prediction
        with torch.no_grad():
            outputs = tf_model.generate(past_values=past_values, past_time_features=past_time_features,
                    static_real_features=static_real_features, past_observed_mask=past_observed_mask,
                    future_time_features=future_time_features).sequences.mean(dim=1)
            outputs = gru_model(outputs, past_time_features).detach().cpu().numpy()
        return outputs[0,0,0], outputs[0,0,1]

    def _get_reward(self, long, lat, fc):
        # reward 1 distance to the top 1
        reward1 = - ((long-self.top1.loc[self.current_step, "LONGITUDE"])**2 + (lat-self.top1.loc[self.current_step, "LATITUDE"])**2 )**0.5
        if reward1 > -0.05:
            reward1 = 0
        reward1 = reward1*10
        # reward 2 fc and done reward
        reward2 = -fc
        # reward 3 mimic reward
        if self.current_step < len(self.data):
            reward3 = - ((long-self.data[self.current_step, 19])**2 + (lat-self.data[self.current_step, 18])**2 )**0.5
        else:
            reward3 = - ((long-self.data[-1, 19])**2 + (lat-self.data[-1, 18])**2 )**0.5
        # reward 4 timeout reward
        reward4 = 0
        if self.current_step >= 100:
            reward4 = -0.1*((self.current_step-90)//10)
        # return (reward1 + reward2 + reward3 + reward4) / 4
        if self.reward_type == "mimic":
            self.reward = (reward1 + reward2 + reward3 + reward4) / 4
        elif self.reward_type == "top1":
            self.reward = (reward1+reward2+reward4) / 3
        else:
            self.reward = (reward2+reward4) /2

        return self.reward

    def step(self, action):
        obs= self._get_observation()
        self.current_step += 1

        fc, sog, lat, long = self._take_action(action)

        # get done and termination
        done = (((long-self.goal_long)**2 + (lat-self.goal_lat)**2) < 1e-2)
        termination =  self.current_step >= self.max_steps

        reward = self._get_reward(long, lat, fc)
        self.reward_cum = self.reward_cum + reward

        if done:
            reward = reward+1/3

        self.reward = reward
        return obs, reward, done, termination, {}

    def _inv_transform_location(self, lat, long):
        array = np.zeros([1, 12],dtype=np.float64)
        array[0, [7,8]] = lat, long
        lat, long = self.scaler.inverse_transform(array)[0,[7, 8]]
        return lat, long

    def _transform_value(self, vals, indexes):
        # transform_cols = [ 'current', 'rain', 'snowfall', "pressure", 'wind_force', "resist_ratio",
        #            'FC', "LATITUDE", 'LONGITUDE', 'SOG', "DEPTH", "SPEED"]
        array = np.zeros([1, 12],dtype=np.float64)
        for i in range(len(indexes)):
            array[0, indexes[i]] = vals[i]
        transformed_val = self.scaler.transform(array)[0, [indexes]]
        return transformed_val[0]

    def _reset(self):
        self.ax.clear()
        self.reset()
        self.status = "Reset"
        self.done = False

        # set the constant values for the plot
        self.ax.set_xlim(xmin = -124.0, xmax= -123.2)
        self.ax.set_ylim(ymin=49.15, ymax=49.45)
        plt.xticks(fontsize=7)
        plt.yticks(fontsize=7)
        # make the axis equal
        self.ax.set_aspect('equal', adjustable='box')
        # grid the axis
        self.ax.grid(True, which='both')
        # increase the precision of the axis
        self.ax.yaxis.set_major_locator(plt.MultipleLocator(0.05))
        if not self.scale_var:
            # change the x,y tick values
            self.ax.set_xticklabels(np.round(np.arange(-0.06, 1.10, 0.14),4).tolist())
            self.ax.set_yticklabels(np.round(np.arange(-0.38, 1.08 , 0.2),4).tolist())
        self._update_results()

    # create  attribute '_next_step' for button widget
    def _next_step(self, flag=False):
        if self.manual:
            #self.actions = np.append(self.actions, np.expand_dims(np.array([self.speed_var.get(), self.heading_var.get(), self.mode_var.get()]), 0), axis=0)
            self.actions = np.append(self.actions, np.expand_dims(np.array([self.speed_var, self.heading_var, self.mode_var]), 0), axis=0)

        else: # from dataset
            self.actions = np.append(self.actions, np.expand_dims(np.array(self.rl_data[self.trip_id]["actions"][self.current_step]), 0), axis=0)
        action = self.actions[-1]
        obs, reward, self.done, termination, _ = self.step(action)
        print("step: ", self.current_step, "reward: ", reward, "cumulative reward: ", self.reward_cum, self.manual)
        if self.done:
            print("Done")
        if termination:
            print("Termination")
        #self.root.update()
        if not flag:
            self.status = "Done"
        #self._update_results()
        self._update_results_pyqt(flag=True)

    def _resume(self):
        if self.run:
            self.run = False
            self.status = "Stopped"
            #self._update_results()
            self._update_results_pyqt(flag=True)
        else:
            self.run = True
            self.status = "Running ..."
        while self.run and self.current_step < self.max_steps and not self.done:
            self.status = "Running ..."
            self._next_step(flag=True)
            #self.root.update()
            # make delay
            #self.root.after(500)

            QtWidgets.QApplication.processEvents()
            time.sleep(0.5)

        if self.current_step > self.max_steps:
            self.status = "Reached max steps"
        if self.done:
            self.status = "Reached goal"
        #self._update_results()
        self._update_results_pyqt(flag=True)

    def _update_results(self):
        root = self.root
        # figures
        lat, long = self.obs[:, -2].copy(), self.obs[:, -1].copy()
        for i in range(len(lat)):
            lat[i], long[i] = self._inv_transform_location(lat[i],long[i])

        # ax.scatter(long_lat[:,1],long_lat[:,0],c=stw, s=1)
        self.ax.scatter(long,lat, s=1, color="blue")
        # creat a circle to show the goal
        goal_loc = self._inv_transform_location(self.goal_lat, self.goal_long)
        circle = plt.Circle((goal_loc[1], goal_loc[0]), 0.02, color='r')
        self.ax.add_artist(circle)
        # ax.axis("off")
        # plt.subplots_adjust(top=0.925,    # Further fix clipping of text in the figure
                            # bottom=0.16,
                            # left=0.11,
                            # right=0.90,
                            # hspace=0.2,
                            # wspace=0.2)

        # add an arow to show the current heading and stick it to the scatter point
        heading = self.actions[-2, 1] if self.direction else self.actions[-2, 1]+np.pi
        # delete the previous arrow
        for i in range(len(self.ax.get_children())-3):
            if str(self.ax.get_children()[i])=='FancyArrow()':
                self.ax.get_children()[i].remove()
        self.ax.arrow(long[-1], lat[-1], 0.0005*np.cos(heading), 0.0005*np.sin(heading), width=0.005, color="red")

        canvas = FigureCanvasTkAgg(self.fig, master=root)
        canvas.draw()
        canvas.get_tk_widget().grid(row=0, column=0, columnspan=3, sticky=W+E+N+S)

        # show the current step, reward and cumulative reward in the GUI in colomn 1
        step_label = Label(root, text="Step: "+str(self.current_step))

        step_label.grid(row=2, column=0, sticky=W+E+N+S)
        reward_label = Label(root, text="Current Reward: "+str(round(self.reward, 3)))
        reward_label.grid(row=2, column=2, sticky=W+E+N+S)
        reward_cum_label = Label(root, text="Cumulative Reward: "+str(round(self.reward_cum, 3)))
        reward_cum_label.grid(row=2, column=1, sticky=W+E+N+S)
        current_engine_label = Label(root, text="Type: Manual" if self.manual else "Type: Auto")
        current_engine_label.grid(row=3, column=1, sticky=W+E+N+S)

        shows = self.obs[-1].copy()
        if self.scale_var:
            # transformed values in  the original space
            # transform_cols = [ 'current', 'rain', 'snowfall', "pressure", 'wind_force', "resist_ratio",
            # 'FC', "LATITUDE", 'LONGITUDE', 'SOG', "DEPTH", "SPEED"]
            array1 = np.array([shows[4],shows[5],shows[6],0, shows[7], shows[9],shows[16], shows[18], shows[19], shows[17],0,self.actions[-1, 0]  ])
            array1 = array1[np.newaxis, :]
            array1 = self.scaler.inverse_transform(array1)
            array1 = array1[0,:]
            shows[4:7] = array1[0:3]
            shows[7] = array1[4]
            shows[9] = array1[5]
            shows[16:20] = [array1[6],array1[9],array1[7],array1[8]]
        # show the observation in the GUI in colomn 1
        #  [0"Time2", 1"turn", 2"acceleration", 3"distance",
        #    4'current', 5'rain', 6'snowfall',7 'wind_force',8 'wind_direc', 9"resist_ratio",
        #   '10change_x_factor', '11change_y_factor',
        #    12"is_weekday",13 'direction', 14"season",15"hour",
        #    16"FC", 17"SOG", 18"LATITUDE", 19'LONGITUDE',
        obs_label = Label(root, text="Observations: " + \
                          "\nFC: "+str(round(shows[ 16], 3)) +\
                          "\nSOG: "+str(round(shows[17], 3)) +\
                            "\nLatitude: "+str(round(shows[18], 3)) +\
                            "\nLongitude: "+str(round(shows[ 19], 3)) +\
                          "\nTurn: "+str(round(shows[1], 3))  + \
                            "\nAcceleration: "+str(round(shows[2], 3))  + \
                            "\nDistance: "+str(round(shows[3], 3))+ \
                            "\nCurrent: "+str(round(shows[4], 3))+ \
                            "\nWind Force: "+str(round(shows[7], 3))+ \
                            "\nWind Direction: "+str(round(shows[8], 3))+ \
                            "\nResist Ratio: "+str(round(shows[9], 3))+ \
                            "\nIs Weekday: "+str(round(shows[12], 3))+ \
                            "\nSeason: "+str(round(shows[14], 3))+ \
                            "\nHour: "+str(round(shows[15], 3))+ \
                            "\nDirection: "+str(round(shows[13], 3)))
        obs_label.grid(row=0, column=3, sticky=W+E+N+S)

        #   show the actions in the GUI in colomn 1
        obs_label = Label(root, text="Applied actions ")
        obs_label.grid(row=3, column=2, sticky=W+E+N+S)
        text0 = str(round(self.actions[-1, 0], 3)) if not self.scale_var else str(round(array1[-1], 3))
        obs_label = Label(root, text=text0)
        obs_label.grid(row=4, column=2, sticky=W+E+N+S)
        obs_label = Label(root, text=str(round(self.actions[-1, 1], 3)))
        obs_label.grid(row=5, column=2, sticky=W+E+N+S)
        obs_label = Label(root, text=str(round(self.actions[-1, 2], 3)))
        obs_label.grid(row=6, column=2, sticky=W+E+N+S)

        status_label = Label(root, text="Status: \n"+self.status)
        status_label.grid(row=2, column=3, rowspan=2, sticky=W+E+N+S)

    def render(self):
        #define the GUI root
        self.status = "Innitialized"
        root = tk.Tk()
        self.root  = root
        # title
        root.title("West coast vessel simulator")
        # create a canvas object and display it
        root.geometry('700x400')


        # generate the figure and plot object which will be linked to the root element
        self.fig, self.ax = plt.subplots()
        self.fig.set_size_inches(5.5, 2.5)

        # set the constant values for the plot
        self.ax.set_xlim(xmin = -124.0, xmax= -123.2)
        self.ax.set_ylim(ymin=49.15, ymax=49.45)
        plt.xticks(fontsize=7)
        plt.yticks(fontsize=7)
        # make the axis equal
        self.ax.set_aspect('equal', adjustable='box')
        # grid the axis
        self.ax.grid(True, which='both')
        # increase the precision of the axis
        self.ax.yaxis.set_major_locator(plt.MultipleLocator(0.05))

        # get curent x/yticklabels only the list of values
        self.xticklabels = np.round(self.ax.get_xticks(),2).tolist()
        self.yticklabels = np.round(self.ax.get_yticks(),2).tolist()

        self.ax.set_xticklabels(np.round(np.arange(-0.06, 1.10, 0.14),4).tolist())
        self.ax.set_yticklabels(np.round(np.arange(-0.38, 1.08 , 0.2),4).tolist())

        # update the results
        self._update_results()

        # create a button widget which will be linked to the button_click function
        button1 = Button(root, text="Next Step", command=self._next_step)
        button1.grid(row=1, column=0, sticky=W+E+N+S)
        # create a button widget which will be linked to the reset function
        button2 = Button(root, text="Reset", command=self._reset)
        button2.grid(row=1, column=1, sticky=W+E+N+S)

        def _switchButtonState():
            if (mode_entry['state'] == tk.NORMAL):
                speed_entry['state'] = tk.DISABLED
                heading_entry['state'] = tk.DISABLED
                mode_entry['state'] = tk.DISABLED
                self.manual = False
            else:
                speed_entry['state'] = tk.NORMAL
                heading_entry['state'] = tk.NORMAL
                mode_entry['state'] = tk.NORMAL
                self.manual = True

        def _switchButtonState1():
            if (self.scale_var == True):
                self.scale_var = False
                # change the x,y tick values
                self.ax.set_xticklabels(np.round(np.arange(-0.06, 1.10, 0.14),4).tolist())
                self.ax.set_yticklabels(np.round(np.arange(-0.38, 1.08 , 0.2),4).tolist())
                self._update_results()
            else:
                self.scale_var = True
                self.ax.set_xticklabels(self.xticklabels)
                self.ax.set_yticklabels(self.yticklabels)
                self._update_results()

        # create button widget that change label from auto to manual and viceversal as click with the states
        button3 = tk.Button(root, text="Auto/manual",command = _switchButtonState)
        button3.grid(row=3, column=0, sticky=W+E+N+S)

        button4 = tk.Button(root, text="Resume/stop",command = self._resume)
        button4.grid(row=1, column=2, sticky=W+E+N+S)

        # change the self.scale_var to true or false as the user click on the button
        button5 = tk.Button(root, text="scaled/actual", command = _switchButtonState1)
        button5.grid(row=1, column=3, sticky=W+E+N+S)

        self.speed_var = DoubleVar()
        self.heading_var = DoubleVar()
        self.mode_var = IntVar()
        self.speed_var.set(0.5)
        self.heading_var.set(0.5)
        self.mode_var.set(0)
        speed_label = Label(root, text="Speed")
        speed_label.grid(row=4, column=0, sticky=W+E+N+S)
        speed_entry = Entry(root, textvariable=self.speed_var, state=tk.DISABLED)
        speed_entry.grid(row=4, column=1, sticky=W+E+N+S)
        heading_label = Label(root, text="Heading")
        heading_label.grid(row=5, column=0, sticky=W+E+N+S)
        heading_entry = Entry(root, textvariable=self.heading_var, state=tk.DISABLED)
        heading_entry.grid(row=5, column=1, sticky=W+E+N+S)
        mode_label = Label(root, text="Mode")
        mode_label.grid(row=6, column=0, sticky=W+E+N+S)
        mode_entry = Entry(root, textvariable=self.mode_var, state=tk.DISABLED)
        mode_entry.grid(row=6, column=1, sticky=W+E+N+S)

        # start the GUI event loop
        root.mainloop()

        # create a canvas object and place it in the window
        # canvas = FigureCanvasTkAgg(fig,master=root_window)
        # canvas.draw()
        # canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=1)

    # Change starts here:
    class Ui_Form_heading(object):
        def setupUi(self, Form):
            Form.setObjectName("Form")
            Form.resize(190, 190)                     # modify

            self.heading_opt = QtWidgets.QLabel(Form)
            self.heading_opt.setGeometry(QtCore.QRect(0, 0, 190, 190))  # modify
            self.heading_opt.setText("")
            self.heading_opt.setPixmap(QtGui.QPixmap(".\\heading_opt.png"))
            self.heading_opt.setObjectName("heading_opt")
            self.heading_opt.setAlignment(QtCore.Qt.AlignCenter)

            self.dial = QtWidgets.QLabel(Form)
            self.dial.setGeometry(QtCore.QRect(0, 0, 190, 190))     # modify
            self.dial.setText("")
            self.dial.setPixmap(QtGui.QPixmap(".\\dial.png"))
            self.dial.setObjectName("dial")
            self.dial.setAlignment(QtCore.Qt.AlignCenter)

            self.retranslateUi(Form)
            QtCore.QMetaObject.connectSlotsByName(Form)

        def retranslateUi(self, Form):
            _translate = QtCore.QCoreApplication.translate
            Form.setWindowTitle(_translate("Form", "Form"))

    class Ui_Form_throttle(object):
        def setupUi(self, Form):
            Form.setObjectName("Form")
            Form.resize(190, 190)                       # modify

            self.throttle = QtWidgets.QLabel(Form)
            self.throttle.setGeometry(QtCore.QRect(0, 0, 190, 190))     # modify
            self.throttle.setText("")
            self.throttle.setPixmap(QtGui.QPixmap(".\\throttle.png"))
            self.throttle.setObjectName("throttle")
            self.throttle.setAlignment(QtCore.Qt.AlignCenter)

            self.throttle_opt = QtWidgets.QLabel(Form)
            self.throttle_opt.setGeometry(QtCore.QRect(0, 0, 190, 190))   # modify
            self.throttle_opt.setText("")
            self.throttle_opt.setPixmap(QtGui.QPixmap(".\\throttle_opt.png"))
            self.throttle_opt.setObjectName("throttle_opt")
            self.throttle_opt.setAlignment(QtCore.Qt.AlignCenter)

            self.gauge = QtWidgets.QLabel(Form)
            self.gauge.setGeometry(QtCore.QRect(0, 0, 190, 190))      # modify
            self.gauge.setText("")
            self.gauge.setPixmap(QtGui.QPixmap(".\\gauge.png"))
            self.gauge.setObjectName("gauge")
            self.gauge.setAlignment(QtCore.Qt.AlignCenter)

            self.retranslateUi(Form)
            QtCore.QMetaObject.connectSlotsByName(Form)

        def retranslateUi(self, Form):
            _translate = QtCore.QCoreApplication.translate
            Form.setWindowTitle(_translate("Form", "Form"))

    class dial(QWidget):
      # fix size
        def __init__(self, parent):
            super().__init__()
            self.parent = parent
            self.setFixedSize(190, 210)             # modify
            self.init_ui()

        def init_ui(self):
            self.dial_widget = QWidget()
            self.dial_ui = self.parent.Ui_Form_heading()
            self.dial_ui.setupUi(self.dial_widget)

            self.heading_opt = Image.open("heading_opt.png")

            layout = QVBoxLayout()
            layout.setContentsMargins(0, 0, 0, 0)       # modify
            layout.setSpacing(0)                 # modify

            layout.addWidget(self.dial_widget)

            # Add a label widget to name the dial
            self.label = QLabel('Heading')
            self.label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)  # modify
            self.label.setAlignment(Qt.AlignTop | Qt.AlignCenter)       # modify
            layout.addWidget(self.label)

            self.setLayout(layout)

        def update(self, heading, heading_opt):
          #fix
            #turn = -(heading_opt-heading) * 360
            turn = (heading-0) * 360

            rotate = QtGui.QPixmap.fromImage(ImageQt(self.heading_opt.rotate(-int(turn))))
            self.dial_ui.heading_opt.setPixmap(rotate)

    class gauge(QWidget):
        def __init__(self, parent):
            super().__init__()
            self.parent = parent
            self.setFixedSize(190, 210)       # modify
            self.init_ui()

        def init_ui(self):
            # fix
            self.rpm = [140, 140, 140, 150, 158, 165, 172, 183, 195, 197, 200]
            self.throttle_lever = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

            self.gauge_widget = QWidget()
            self.gauge_ui = self.parent.Ui_Form_throttle()
            self.gauge_ui.setupUi(self.gauge_widget)

            self.throttle = Image.open("throttle.png")
            self.throttle_opt = Image.open("throttle_opt.png")

            layout = QVBoxLayout()
            layout.setContentsMargins(0, 0, 0, 0)   # modify
            layout.setSpacing(0)            # modify

            layout.addWidget(self.gauge_widget)

            self.label = QLabel('Throttle(N/ARPM)')
            self.label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)  # modify
            self.label.setAlignment(Qt.AlignTop | Qt.AlignCenter)       # modify
            layout.addWidget(self.label)


            self.setLayout(layout)

        def update(self, throttle, throttle_opt):
            self.label.setText(f'Throttle({int(throttle)}RPM)')

            # fix
            throttle = ((throttle-450)/100 * 60) + 140
            throttle_opt = ((throttle_opt-450)/100 * 60) + 140

            throttle_position = 0
            throttle_opt_position = 0

            for index, item in enumerate(self.rpm):
                if item >= throttle:
                    if index == 0:
                        throttle_position = 2
                    else:
                        throttle_position = ((throttle-self.rpm[index-1])/(self.rpm[index]-self.rpm[index-1]) * (self.throttle_lever[index]-self.throttle_lever[index-1])) + self.throttle_lever[index-1]
                    break

            for index, item in enumerate(self.rpm):
                if item >= throttle_opt:
                    if index == 0:
                        throttle_opt_position = 2
                    else:
                        throttle_opt_position = ((throttle-self.rpm[index-1])/(self.rpm[index]-self.rpm[index-1]) * (self.throttle_lever[index]-self.throttle_lever[index-1])) + self.throttle_lever[index-1]
                    break

            throttle_position = int((throttle_position/10)*(185/2))
            throttle_opt_position = int((throttle_opt_position/10)*(185/2))

            throttle_pixmap = QtGui.QPixmap.fromImage(ImageQt(self.throttle))
            throttle_opt_pixmap = QtGui.QPixmap.fromImage(ImageQt(self.throttle_opt))

            # modify after resizing
            self.gauge_ui.throttle.setPixmap(throttle_pixmap)
            self.gauge_ui.throttle.move(self.gauge_ui.throttle.x(), -throttle_position)

            self.gauge_ui.throttle_opt.setPixmap(throttle_opt_pixmap)
            self.gauge_ui.throttle_opt.move(self.gauge_ui.throttle_opt.x(), -throttle_opt_position)

    class canvas(FigureCanvas):
        def __init__(self, parent):
            self.fig, self.ax = plt.subplots(figsize=(1, 1), dpi=100)   # modify
            super().__init__(self.fig)
            self.setParent(parent)
            self.auto = False
            self.samples = 60
            self.x_lb = 0
            self.x_ub = 0
            self.y_lb = 0
            self.y_ub = 0
            self.zoom = 1
            self.interval = 0
            self.init_ui()

        def init_ui(self):
            self.sfc = []
            self.line_sfc, = self.ax.plot(self.sfc, label='Current SFC')
            self.sfc_opt = []
            self.line_sfc_opt, = self.ax.plot(self.sfc_opt, label='Optimal SFC')

            self.ax.set(xlabel='time (min)', ylabel='SFC (L/h)', title='SFC')
            self.fig.subplots_adjust(left=0.22, right=0.9, top=0.88, bottom=0.25)   # modify
            self.ax.legend()
            self.ax.grid()
            self.rstLim()

        def _setLim(self):
            self.x_lb = int(self.interval)
            self.x_ub = self.x_lb + int(self.samples / self.zoom)
            self.y_lb, self.y_ub = self._getRange(self.x_lb, self.x_ub)
            self.y_lb -= 10
            self.y_ub += 10

            self.ax.set_xlim(self.x_lb, self.x_ub)
            self.ax.set_ylim(self.y_lb, self.y_ub)

            self.draw()

        def zoomIn(self):
            self.auto = False
            if self.zoom < 10:
                self.zoom += 1
                self._setLim()

        def zoomOut(self):
            self.auto = False
            if self.zoom > 1:
                self.zoom -= 1
                self._setLim()

        def moveLeft(self):
            self.auto = False
            if self.interval > 0:
                if (self.interval - (self.samples / self.zoom)) > 0:
                    self.interval -= self.samples / self.zoom
                else:
                    self.interval = 0

                self._setLim()

        def moveRight(self):
            self.auto = False
            if (self.interval + (self.samples / self.zoom)) < len(self.sfc):
                self.interval += self.samples / self.zoom
                self._setLim()

        def rstLim(self):
            self.auto = True
            self.zoom = 1
            self.interval = len(self.sfc)
            self._setLim()

        def _getRange(self, x_lb, x_ub):
            if x_ub > len(self.sfc):
                x_ub = len(self.sfc)

            y_range = self.sfc[x_lb:x_ub]

            if y_range:
                y_lb = int(min(y_range))
                y_ub = int(max(y_range))
                return y_lb, y_ub
            else:
                return 0, 0

        def update_plot(self, sfc, sfc_opt):
            self.sfc.append(sfc)
            self.sfc_opt.append(sfc_opt)

            if self.auto and (len(self.sfc) > self.x_ub):
                self.interval = len(self.sfc)

            self.line_sfc.set_ydata(self.sfc)
            self.line_sfc.set_xdata(np.arange(len(self.sfc)))
            self.line_sfc_opt.set_ydata(self.sfc_opt)
            self.line_sfc_opt.set_xdata(np.arange(len(self.sfc_opt)))
            self.ax.autoscale_view()    # modify
            self._setLim()
            self.draw()

    class plot(QWidget):
        def __init__(self, parent):
            super().__init__()
            self.parent = parent
            self.chart = self.parent.canvas(self)
            self.chart.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # modify
            self.init_ui()

        def init_ui(self):
            layout = QVBoxLayout()
            layout.setContentsMargins(0, 0, 0, 0)   # modify

            zoom_layout = QVBoxLayout()
            zoom_in = QPushButton('+')
            zoom_out = QPushButton('-')
            zoom_in.clicked.connect(self.setZoom)
            zoom_out.clicked.connect(self.setZoom)
            zoom_in.setFixedSize(50, 50)    # modify
            zoom_out.setFixedSize(50, 50)   # modify
            #zoom_in.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)    # modify
            #zoom_out.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)   # modify
            zoom_layout.addWidget(zoom_in)
            zoom_layout.addWidget(zoom_out)

            interval_layout = QHBoxLayout()
            left = QPushButton('←')
            right = QPushButton('→')
            left.clicked.connect(self.setInterval)
            right.clicked.connect(self.setInterval)
            #left.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)   # modify
            #right.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)    # modify
            interval_layout.addWidget(left)
            interval_layout.addStretch()
            interval_layout.addWidget(right)

            rst = QPushButton('RST')
            rst.clicked.connect(self.reset)
            #rst.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)    # modify
            interval_layout.addWidget(rst)

            chart_layout = QHBoxLayout()
            chart_layout.addWidget(self.chart)
            chart_layout.addLayout(zoom_layout)

            layout.addLayout(chart_layout)
            layout.addLayout(interval_layout)

            self.setLayout(layout)

        def setZoom(self):
            sender = self.sender()
            button_text = sender.text()

            if button_text == '+':
                self.chart.zoomIn()
            elif button_text == '-':
                self.chart.zoomOut()

        def setInterval(self):
            sender = self.sender()
            button_text = sender.text()

            if button_text == '←':
                self.chart.moveLeft()
            elif button_text == '→':
                self.chart.moveRight()

        def reset(self):
            self.chart.rstLim()

        def update(self, sfc, sfc_opt):
            self.chart.update_plot(sfc, sfc_opt)

    # Information panel widget
    class panel(QWidget):
        def __init__(self, parent):
            super().__init__()
            self.parent = parent
            self.info = {}
            self.row = 2
            self.col = 4
            self.current_page = 0
            self.setFixedSize(750, 190)   # modify
            self.init_ui()

        def init_ui(self):
            self.grid = QGridLayout()
            self.grid.setSpacing(10)    # modify

            self.labels = []

            for i in range(self.row):
                for j in range(self.col):
                    label = QLabel(self)
                    label.setFrameShape(QFrame.Box)   # modify
                    label.setStyleSheet("padding: 5px; border: 1px solid black")  # modify
                    self.grid.addWidget(label, i, j)
                    self.labels.append(label)

            self.update(self.info)

            self.prev_button = QPushButton('←', self)
            self.prev_button.clicked.connect(self.prev_page)
            self.prev_button.setStyleSheet("color: white; background-color: black; border: none; font-size: 18px;") # modify

            self.next_button = QPushButton('→', self)
            self.next_button.clicked.connect(self.next_page)
            self.next_button.setStyleSheet("color: white; background-color: black; border: none; font-size: 18px;") # modify

            button_layout = QHBoxLayout()
            button_layout.addWidget(self.prev_button)
            button_layout.addStretch()          # modify
            button_layout.addWidget(self.next_button)

            layout = QVBoxLayout()
            layout.addLayout(self.grid)
            layout.addLayout(button_layout)

            self.setLayout(layout)

        def prev_page(self):
            if self.current_page > 0:
                self.current_page -= 1
                self.update(self.info)

        def next_page(self):
            self.current_page += 1
            self.update(self.info)

        def update(self, info):
            self.info = info
            start_index = self.current_page*self.row*self.col
            keys = list(info.keys())
            values = list(info.values())

            for k in range(self.row*self.col):
                if (start_index+k) < len(info):
                    self.labels[k].setText(keys[start_index+k] + '\n' + values[start_index+k])
                else:
                    self.labels[k].setText(f'Label {start_index+k+1}')

    class pad(QWidget):
        def __init__(self, parent):
            super().__init__()
            self.parent = parent
            self.actions = {}
            self.input_labels = ['ETA', 'Speed', 'Heading', 'Mode']
            self.labels = []
            self.textboxes = []
            self.labels_action = []
            self.current_textbox = 0
            self.input_enabled = False
            self.label_type = None
            self.label_step = None
            self.label_cum_rwd = None
            self.label_cur_rwd = None
            self.label_status = None

            self.init_ui()

        def init_ui(self):
            input_layout = QHBoxLayout()

            text_layout = QVBoxLayout()

            title_layout = QHBoxLayout()

            label = QLabel('')
            label.setFixedWidth(100)      # modify
            title_layout.addWidget(label)

            self.label_type = QLabel('Type: N/A')
            self.label_type.setFixedSize(150, 50)   # modify
            title_layout.addWidget(self.label_type)

            label = QLabel('Applied Actions')
            label.setFixedSize(200, 50)       # modify
            title_layout.addWidget(label)

            label = QLabel('')
            label.setFixedWidth(50)       # modify
            title_layout.addWidget(label)

            text_layout.addLayout(title_layout)

            for input_label in self.input_labels:
                row_layout_text = QHBoxLayout()
                label = QLabel(f'{input_label}:')
                label.setFixedWidth(50)       # modify

                textbox = QLineEdit()
                textbox.setFixedSize(150, 50)   # modify
                textbox.setEnabled(self.input_enabled)

                label_action = QLabel('N/A')
                label_action.setFixedSize(150, 50)  # modify

                row_layout_text.addWidget(label)
                row_layout_text.addWidget(textbox)
                row_layout_text.addWidget(label_action)
                text_layout.addLayout(row_layout_text)

                self.labels.append(label)
                self.textboxes.append(textbox)
                self.labels_action.append(label_action)

            status_layout = QVBoxLayout()

            # fix
            self.label_step = QLabel('Step: N/A')
            status_layout.addWidget(self.label_step)
            self.label_cum_rwd = QLabel('Cumulative Reward: N/A')
            status_layout.addWidget(self.label_cum_rwd)
            self.label_cur_rwd = QLabel('Current Reward: N/A')
            status_layout.addWidget(self.label_cur_rwd)
            self.label_status = QLabel('Status: N/A')
            status_layout.addWidget(self.label_status)

            input_layout.addLayout(text_layout)
            input_layout.addLayout(status_layout)

            buttons = [
                ['1', '2', '3', '↑'],
                ['4', '5', '6', '↓'],
                ['7', '8', '9', 'CLR'],
                ['', '0', '.', 'ENT'],
                ['Stop/Resume', 'Next Step', 'Reset'],
                ['Auto/Manual', 'Scaled/Actual', '']
            ]

            button_layout = QVBoxLayout()

            for row in buttons:
                row_layout_button = QHBoxLayout()

                for buttonText in row:
                    button = QPushButton(buttonText)
                    button.clicked.connect(self.buttonClicked)
                    button.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # modify
                    row_layout_button.addWidget(button)

                button_layout.addLayout(row_layout_button)

            layout = QVBoxLayout()
            layout.addLayout(input_layout)
            layout.addLayout(button_layout)

            self.setLayout(layout)

            # automate this
            self.textboxes[0].setText('00:00')
            self.textboxes[1].setText('0.5')
            self.textboxes[2].setText('0.5')
            self.textboxes[3].setText('0')

            if self.textboxes:
                self.textboxes[0].setFocus()

        def buttonClicked(self):
            sender = self.sender()
            numClicked = sender.text()

            if numClicked.isdigit() or numClicked == '.':
                current_text = self.textboxes[self.current_textbox].text()

                if ':' in current_text:
                    if numClicked.isdigit():
                        hr_str = current_text[0:2]
                        min_str = current_text[3:5]
                        current_text = hr_str[1] + min_str[0] + ':' + min_str[1] + numClicked
                else:
                    current_text += numClicked

                self.textboxes[self.current_textbox].setText(current_text)
                self.labels[self.current_textbox].setText(f'{self.input_labels[self.current_textbox]}*:')
            elif numClicked == '↑':
                self.navigate_textbox(-1)
            elif numClicked == '↓':
                self.navigate_textbox(1)
            elif numClicked == 'CLR':
                current_text = self.textboxes[self.current_textbox].text()

                if ':' in current_text:
                    current_text = '00:00'
                else:
                    current_text = ''

                self.textboxes[self.current_textbox].setText(current_text)
                self.labels[self.current_textbox].setText(f'{self.input_labels[self.current_textbox]}*:')
            elif numClicked == 'ENT':
                values = self.get_textbox_values()

                for i in range(len(values)):
                    if values[i]:
                        if ':' in values[i]:
                            eta = values[i]
                            hr, min = map(int, eta[0:5].split(':'))
                            sec = (hr*60+min)*60
                            values[i] = sec
                        else:
                            values[i] = float(values[i])
                    else:
                        values[i] = 0

                # update this automatically by using a list
                self.parent.eta_var = eta
                self.parent.total_sec = values[0]
                self.parent.speed_var = values[1]
                self.parent.heading_var = values[2]
                self.parent.mode_var = values[3]

                for index, label in enumerate(self.labels):
                    label.setText(f'{self.input_labels[index]}:')
            elif numClicked == 'Stop/Resume':
                self.parent._resume()
            elif numClicked == 'Next Step':
                self.parent._next_step()
            elif numClicked == 'Reset':
                self.parent._reset_pyqt()
            elif numClicked == 'Auto/Manual':
                self.toggle_inputs()

                # when manual -> auto, assign back the values to textboxes
            elif numClicked == 'Scaled/Actual':
                if (self.parent.scale_var == True):
                    self.parent.scale_var = False
                    self.parent._update_results_pyqt(flag=False)
                else:
                    self.parent.scale_var = True
                    self.parent._update_results_pyqt(flag=False)

        def toggle_inputs(self):
            self.input_enabled = not self.input_enabled
            self.parent.manual = not self.parent.manual

            for textbox in self.textboxes:
                textbox.setEnabled(self.input_enabled)

        def navigate_textbox(self, direction):
            if self.textboxes:
                self.current_textbox = (self.current_textbox + direction) % len(self.textboxes)
                self.textboxes[self.current_textbox].setFocus()

        def get_textbox_values(self):
            textbox_values = []
            for textbox in self.textboxes:
                textbox_values.append(textbox.text())
            return textbox_values

        def update(self, actions):
            # fix
            # may not need self.action. just action
            self.actions = actions

            # automate this
            self.labels_action[0].setText(actions['ETA'])
            self.labels_action[1].setText(actions['Speed'])
            self.labels_action[2].setText(actions['Heading'])
            self.labels_action[3].setText(actions['Mode'])

            self.label_type.setText(f"Type: {actions['Type']}")
            self.label_step.setText(f"Step: {actions['Step']}")
            self.label_cum_rwd.setText(f"Cumulative Reward: {actions['Cumulative Reward']}")
            self.label_cur_rwd.setText(f"Current Reward: {actions['Current Reward']}")
            self.label_status.setText(f"Status: {actions['Status']}")

    def _reset_pyqt(self):
        self.reset()
        self.status = "Reset"
        self.done = False

        if self.sfc_plot:
            self.sfc_plot.clear()
        self._update_results_pyqt(flag=False)

    def _scaler(self, shows, speed):
        shows_scaled = shows
        # transformed values in  the original space
        # transform_cols = [ 'current', 'rain', 'snowfall', "pressure", 'wind_force', "resist_ratio",
        #            'FC', "LATITUDE", 'LONGITUDE', 'SOG', "DEPTH", "SPEED"]
        array1 = np.array([shows[4], shows[5], shows[6], 0, shows[7], shows[9], shows[16], shows[18], shows[19], shows[17], 0, speed])
        array1 = array1[np.newaxis, :]
        array1 = self.scaler.inverse_transform(array1)
        array1 = array1[0, :]
        shows_scaled[4:7] = array1[0:3]
        shows_scaled[7] = array1[4]
        shows_scaled[9] = array1[5]
        shows_scaled[16:20] = [array1[6], array1[9], array1[7], array1[8]]
        speed_scaled = array1[-1]

        return shows_scaled, speed_scaled

    def _update_results_pyqt(self, flag=False):
        shows_current = self.obs[-2].copy()
        shows_predict = self.obs[-1].copy()
        shows_current_scaled, speed_current_scaled = self._scaler(shows_current, self.actions[-2, 0])
        shows_predict_scaled, speed_predict_scaled = self._scaler(shows_predict, self.actions[-1, 0])
        # show the observation in the GUI in colomn 1
        #  [0"Time2", 1"turn", 2"acceleration", 3"distance",
        #    4'current', 5'rain', 6'snowfall',7 'wind_force',8 'wind_direc', 9"resist_ratio",
        #   '10change_x_factor', '11change_y_factor',
        #    12"is_weekday",13 'direction', 14"season",15"hour",
        #    16"FC", 17"SOG", 18"LATITUDE", 19'LONGITUDE',
        info = {
            "FC": str(round(shows_current[16], 3)),
            "SOG": str(round(shows_current[17], 3)),
            "Latitude": str(round(shows_current[18], 3)),
            "Longitude": str(round(shows_current[19], 3)),
            "Turn": str(round(shows_current[1], 3)),
            "Acceleration": str(round(shows_current[2], 3)),
            "Distance": str(round(shows_current[3], 3)),
            "Current": str(round(shows_current[4], 3)),
            "Wind Force": str(round(shows_current[7], 3)),
            "Wind Direction": str(round(shows_current[8], 3)),
            "Resist Ratio": str(round(shows_current[9], 3)),
            "Is Weekday": str(round(shows_current[12], 3)),
            "Season": str(round(shows_current[14], 3)),
            "Hour": str(round(shows_current[15], 3)),
            "Direction": str(round(shows_current[13], 3)),
        }

        actions = {
            "ETA": self.eta_var,
            "Speed": str(round(self.actions[-1, 0], 3)) if not self.scale_var else str(round(speed_predict_scaled, 3)),
            "Heading": str(round(self.actions[-1, 1], 3)),
            "Mode": str(round(self.actions[-1, 2], 3)),
            "Type": "Manual" if self.manual else "Auto",
            "Step": str(self.current_step),
            "Cumulative Reward": str(round(self.reward, 3)),
            "Current Reward": str(round(self.reward_cum, 3)),
            "Status": self.status
        }

        if self.cmp_dial:
            self.cmp_dial.update(round(self.actions[-2, 1], 3), round(self.actions[-1, 1], 3))
        if self.thr_gauge:
            self.thr_gauge.update(round(speed_current_scaled, 3), round(speed_predict_scaled, 3))
        if self.sfc_plot and flag:
            self.sfc_plot.update(round(shows_current[16], 3), round(shows_predict[16], 3))
        if self.info_panel:
            self.info_panel.update(info)
        if self.num_pad:
            self.num_pad.update(actions)
        if self.left_layout:
            self.left_layout.update(int(shows_current[16]), int(shows_predict[16]))
        if self.center_layout:
            self.center_layout.update(int(shows_current[16]), int(shows_predict[16]), 10)
        if self.right_layout:
            self.right_layout.update(int(shows_current[16]), 10, 10)

    class render_pyqt(QWidget):
        def __init__(self, parent):
            super().__init__()
            self.parent = parent
            self.init_ui()

        def init_ui(self):
            self.parent.cmp_dial = self.parent.dial(self.parent)
            self.parent.thr_gauge = self.parent.gauge(self.parent)
            self.parent.sfc_plot = self.parent.plot(self.parent)
            self.parent.info_panel = self.parent.panel(self.parent)
            self.parent.num_pad = self.parent.pad(self.parent)

            layout = QGridLayout()
            layout.setContentsMargins(10, 10, 10, 10)   # modify
            layout.setSpacing(10)               # modify
            layout.addWidget(self.parent.cmp_dial, 0, 0, 4, 2)  # modify
            layout.addWidget(self.parent.thr_gauge, 0, 2, 4, 2)   # modify
            layout.addWidget(self.parent.sfc_plot, 4, 0, 6, 4)  # modify
            layout.addWidget(self.parent.info_panel, 0, 4, 3, 2)  # modify
            layout.addWidget(self.parent.num_pad, 3, 4, 7, 2)   # modify

            self.setLayout(layout)
            self.setWindowTitle('West coast vessel simulator')
            self.setGeometry(320, 220, 800, 480)          # modify

            #timer = QTimer()
            #timer.timeout.connect(self.parent._update_results_pyqt)
            #timer.start(1000)

    # Change ends here

    # New UI starts here

    #w, h, title height, fuel range (change grad & bar & region), %; numbers
    class left(QWidget):
        def __init__(self, parent):
            super().__init__()
            self.parent = parent

            # Init Widgets & Layouts
            self.main_layout = QVBoxLayout()
            self.title = QLabel()
            self.sub_layout = QHBoxLayout()
            self.grad_layout = QVBoxLayout()
            self.bar = QProgressBar()
            self.region_layout = QVBoxLayout()

            self.init_ui()

        def init_ui(self):
            # Title Widget
            self.title.setText("FUEL CONSUMPTION\n(LITER/HOUR)")
            self.title.setStyleSheet("font-size: 18px")
            self.title.setFixedHeight(50)
            self.title.setAlignment(Qt.AlignCenter)

            # Graduation Layout
            for i in range(100, -1, -5):
                grad_line_layout = QHBoxLayout()

                if i % 10 == 0:
                    grad_label = QLabel(f"{i}")
                    grad_label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
                    grad_label.setStyleSheet("font-size: 12px;")
                    grad_line_layout.addWidget(grad_label)
                else:
                    grad_line_layout.addWidget(QLabel())

                grad_line = QFrame()
                grad_line.setFrameShape(QFrame.HLine)
                grad_line.setFrameShadow(QFrame.Sunken)
                grad_line.setStyleSheet("border: 1px solid grey;")
                grad_line.setFixedWidth(10)

                grad_line_layout.addWidget(grad_line)

                self.grad_layout.addLayout(grad_line_layout)

            # Progress Bar Widget
            self.bar.setOrientation(Qt.Vertical)
            self.bar.setMinimum(0)
            self.bar.setMaximum(100)
            self.bar.setValue(50)
            self.bar.setTextVisible(False)
            self.bar.setStyleSheet("QProgressBar {border: 2px solid grey; border-radius: 0px; background: white;} QProgressBar::chunk {background: yellow;}")

            # Color Region Layout
            self.region_red = QLabel()
            self.region_red.setStyleSheet("background-color: red;")
            self.region_red.setFixedWidth(20)
            self.region_red.setFixedHeight(100)

            self.region_green = QLabel()
            self.region_green.setStyleSheet("background-color: green;")
            self.region_green.setFixedWidth(20)
            self.region_green.setFixedHeight(30)

            self.region_blue = QLabel()
            self.region_blue.setStyleSheet("background-color: blue;")
            self.region_blue.setFixedWidth(20)
            self.region_blue.setFixedHeight(300)

            self.region_layout.addWidget(self.region_red)
            self.region_layout.addWidget(self.region_green)
            self.region_layout.addWidget(self.region_blue)
            self.region_layout.setSpacing(0)
            self.region_layout.setContentsMargins(0, 0, 0, 0)

            # Main Layout Assembly
            self.sub_layout.addLayout(self.grad_layout)
            self.sub_layout.addWidget(self.bar)
            self.sub_layout.addLayout(self.region_layout)

            self.main_layout.addWidget(self.title)
            self.main_layout.addLayout(self.sub_layout)

        def update(self, current, predict):
            title_height = 50
            h = 480 - title_height
            ub = 650
            lb = 450
            green_height = int((0.05 * predict) / (ub - lb) * h)
            blue_height = int(((current - (0.05 * predict) / 2) - lb) / (ub - lb) * h)
            red_height = h - green_height - blue_height
            self.bar.setValue(current)
            self.region_red.setFixedHeight(red_height)
            self.region_green.setFixedHeight(green_height)
            self.region_blue.setFixedHeight(blue_height)

    class center(QWidget):
        def __init__(self, parent):
            super().__init__()
            self.parent = parent

            # Init Widgets & Layouts
            self.main_layout = QVBoxLayout()
            self.label_name_1 = QLabel()
            self.label_name_2 = QLabel()
            self.label_1 = QLabel()
            self.label_2 = QLabel()
            self.pixmap_1 = QPixmap()
            self.pixmap_2 = QPixmap()
            self.image = QLabel()

            self.init_ui()

        def init_ui(self):
            # Label Widgets
            self.label_name_1.setText("REAL TIME FUEL CONSUMPTION\n(Liter/Hour)")
            self.label_name_1.setStyleSheet("font-size: 18px")
            self.label_name_1.setFixedHeight(50)
            self.label_name_1.setAlignment(Qt.AlignCenter)
            self.label_1.setText("0")
            self.label_1.setStyleSheet("font-size: 48px; border: 1px solid black;")
            self.label_1.setAlignment(Qt.AlignCenter)

            self.label_name_2.setText("ARRIVAL TIME BASED ON CURRENT LOCATION AND SPEED")
            self.label_name_2.setStyleSheet("font-size: 18px")
            self.label_name_2.setFixedHeight(50)
            self.label_name_2.setAlignment(Qt.AlignCenter)
            self.label_2.setText("00:00:00")
            self.label_2.setStyleSheet("font-size: 48px; border: 1px solid black;")
            self.label_2.setAlignment(Qt.AlignCenter)

            # Image Widgets
            self.pixmap_1 = QPixmap("image_1.png")
            self.pixmap_1 = self.pixmap_1.scaled(100, 100, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.pixmap_2 = QPixmap("image_2.png")
            self.pixmap_2 = self.pixmap_2.scaled(100, 100, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.image.setPixmap(self.pixmap_1)
            self.image.setAlignment(Qt.AlignCenter)

            # Main Layout Assembly
            self.main_layout.addWidget(self.label_name_1)
            self.main_layout.addWidget(self.label_1)
            self.main_layout.addWidget(self.label_name_2)
            self.main_layout.addWidget(self.label_2)
            self.main_layout.addWidget(self.image)

        def update(self, current, predict, eta):
            self.label_1.setText(str(current))
            self.label_2.setText(str(eta))
            if current > predict:
                self.image.setPixmap(self.pixmap_2)
            else:
                self.image.setPixmap(self.pixmap_1)

    class right(QWidget):
        def __init__(self, parent):
            super().__init__()
            self.parent = parent

            # Init Widgets & Layouts
            self.main_layout = QVBoxLayout()
            self.title = QLabel()
            self.label_layout_1 = QHBoxLayout()
            self.label_layout_2 = QHBoxLayout()
            self.label_layout_3 = QHBoxLayout()
            self.label_name_1 = QLabel()
            self.label_name_2 = QLabel()
            self.label_name_3 = QLabel()
            self.label_1 = QLabel()
            self.label_2 = QLabel()
            self.label_3 = QLabel()
            self.table = QTableWidget(5, 3)

            self.init_ui()

        def init_ui(self):
            # Title Widget
            self.title.setText("VOYAGE SUMMARY")
            self.title.setStyleSheet("font-size: 24px;")
            self.title.setAlignment(Qt.AlignCenter)

            # Label Widgets
            self.label_name_1.setText("TOTAL FUEL USED\n(LITRE)")
            self.label_name_1.setStyleSheet("font-size: 18px")
            self.label_name_1.setAlignment(Qt.AlignCenter)
            self.label_1.setText("0")
            self.label_1.setStyleSheet("font-size: 18px; border: 1px solid black;")
            self.label_1.setAlignment(Qt.AlignCenter)
            self.label_layout_1.addWidget(self.label_name_1)
            self.label_layout_1.addWidget(self.label_1)

            self.label_name_2.setText("TRAVEL DISTANCE\n(NMILE)")
            self.label_name_2.setStyleSheet("font-size: 18px")
            self.label_name_2.setAlignment(Qt.AlignCenter)
            self.label_2.setText("0")
            self.label_2.setStyleSheet("font-size: 18px; border: 1px solid black;")
            self.label_2.setAlignment(Qt.AlignCenter)
            self.label_layout_2.addWidget(self.label_name_2)
            self.label_layout_2.addWidget(self.label_2)

            self.label_name_3.setText("SAILING TIME\n(MINUTE)")
            self.label_name_3.setStyleSheet("font-size: 18px")
            self.label_name_3.setAlignment(Qt.AlignCenter)
            self.label_3.setText("0")
            self.label_3.setStyleSheet("font-size: 18px; border: 1px solid black;")
            self.label_3.setAlignment(Qt.AlignCenter)
            self.label_layout_3.addWidget(self.label_name_3)
            self.label_layout_3.addWidget(self.label_3)

            # Table Widget
            self.table.setHorizontalHeaderLabels(["HISTORY", "USED FUEL\n(LITRE)", "SAILING TIME\n(MINUTE)"])
            self.table.setItem(0, 0, QTableWidgetItem("SAILING 1"))
            self.table.setItem(0, 1, QTableWidgetItem("0"))
            self.table.setItem(0, 2, QTableWidgetItem("0"))
            self.table.setItem(1, 0, QTableWidgetItem("SAILING 2"))
            self.table.setItem(2, 0, QTableWidgetItem("SAILING 3"))
            self.table.setItem(3, 0, QTableWidgetItem("SAILING 4"))
            self.table.setItem(4, 0, QTableWidgetItem("SAILING 5"))
            self.table.verticalHeader().setVisible(False)
            self.table.setStyleSheet("font-size: 12px; color: green; border: 1px solid green;")
            self.table.setFixedSize(300, 125 + self.table.horizontalHeader().height())
            for row in range(5):
                self.table.setRowHeight(row, 25)
            for col in range(3):
                self.table.setColumnWidth(col, 100)

            self.table.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
            self.table.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)

            self.table.setStyleSheet("""
                QTableWidget {
                    font-size: 14px;
                    background-color: black;
                    color: white;
                    border: 1px solid white;
                    gridline-color: white;
                }
                QHeaderView::section {
                    background-color: black;
                    color: white;
                    border: 1px solid white;
                }
            """)

            # Main Layout Assembly
            self.main_layout.addWidget(self.title)
            self.main_layout.addLayout(self.label_layout_1)
            self.main_layout.addLayout(self.label_layout_2)
            self.main_layout.addLayout(self.label_layout_3)
            self.main_layout.addWidget(self.table)

        def update(self, cum_fc, dist, time):
            self.label_1.setText(str(cum_fc))
            self.label_2.setText(str(dist))
            self.label_3.setText(str(time))

    class render_pyqt_new(QWidget):
        def __init__(self, parent):
            super().__init__()
            self.parent = parent

            # Window Properties
            self.setWindowTitle("West Coast Vessel Simulator")
            self.setGeometry(0, 0, 800, 480)

            # Init Widgets & Layouts
            self.main_layout = QHBoxLayout()
            self.parent.left_layout = self.parent.left(self.parent)
            self.parent.center_layout = self.parent.center(self.parent)
            self.parent.right_layout = self.parent.right(self.parent)

            self.init_ui()

        def init_ui(self):
            # Main Layout Assembly
            self.main_layout.addWidget(self.parent.left_layout)
            self.main_layout.addWidget(self.parent.center_layout)
            self.main_layout.addWidget(self.parent.right_layout)

            self.setLayout(self.main_layout)

            # Auto Update
            self.parent.scale_var = True
            #self.parent._resume()

            #timer = QTimer()
            #timer.timeout.connect(self.parent._update_results_pyqt)
            #timer.start(1000)

    # New UI ends here

# main function
def main():
    # load data
    with open('data/rl_data.pkl', 'rb') as handle:
        rl_data = pickle.load(handle)
    # load scaler
    scaler=pickle.load(open('data/minmax_scaler.pkl', 'rb'))
    # load top trips
    hn_top = pd.read_csv("data/H2N_top1.csv")
    nh_top = pd.read_csv("data/N2H_top1.csv")
    toptrips = (hn_top, nh_top)

    # load models
    # [tf_loc, tf_fc, gru_loc, gru_fc]
    file_path = (
    "data/gruloc_3_checkpoint22.pt",
    "data/gru_5_checkpoint16.pt",
    "data/gruloc_3_checkpoint22_gru.pt",
    "data/gru_5_checkpoint16_gru.pt")

    # create environment
    env = VesselEnvironment(rl_data, scaler, toptrips, file_path)
    env.reset()
    #env.render()

    app = QApplication(sys.argv)
    window = env.render_pyqt_new(env)
    window.show()

    app.exec_()

    fc_predicted = []
    sog_predicted = []
    lat_predicted = []
    long_predicted = []
    trip_ids = []
    for i in range(2):
        # reset environment
        env.reset()
        trip_ids.append(env.trip_id)

        length = rl_data[env.trip_id]["observations"].shape[0]
        fc = np.zeros((length))
        sog =  np.zeros((length))
        lat = np.zeros((length))
        long = np.zeros((length))
        for j in range(25, length):
            action = rl_data[env.trip_id]["actions"][j]
            # action[1] = action[1]
            obs = env.step(action)[0][-1, :]
            fc[j], sog[j], lat[j], long[j] = obs[-4], obs[-3], obs[-2], obs[-1]
            # if done:
            #     break
        array1 = np.zeros((length, 12))
        array1[:, 6] = fc
        array1[:, 9] = sog
        array1[:, 7] = lat
        array1[:, 8] = long
        array1 = scaler.inverse_transform(array1)
        fc_predicted.append(array1[:, 6])
        sog_predicted.append(array1[:, 9])
        lat_predicted.append(array1[:, 7])
        long_predicted.append(array1[:, 8])
    fcs = []
    sogs = []
    longs = []
    lats = []
    # TODO why i start from 0?
    for j in range(2):
        i = trip_ids[j]
        array = np.zeros((len(rl_data[i]["observations"]), 12))
        array[:, 6] = rl_data[i]["observations"][:, -4]
        array[:, 9] = rl_data[i]["observations"][:, -3]
        array[:, 7] = rl_data[i]["observations"][:, -2]
        array[:, 8] = rl_data[i]["observations"][:, -1]
        array = scaler.inverse_transform(array)
        fcs.append(array[:, 6])
        sogs.append(array[:, 9])
        lats.append(array[:, 7])
        longs.append(array[:, 8])
    # plot
    def plot(i):
        fig = plt.figure()
        grid = plt.GridSpec(2, 2, wspace=0.3, hspace=0.3)

        ax1 = plt.subplot(grid[0, 0])
        ax2 = plt.subplot(grid[0, 1:])
        ax3 = plt.subplot(grid[1, :1])
        ax4 = plt.subplot(grid[1, 1:])

        ax1.plot(range(25, len(fc_predicted[i])), fc_predicted[i][25:], label='predictions'.format(i=2))
        ax1.plot(range(25, len(fc_predicted[i])), fcs[i][25:], label='actuals'.format(i=1))
        ax1.legend(loc='best')
        ax2.plot(range(25, len(fc_predicted[i])), long_predicted[i][25:], label='predictions'.format(i=2))
        ax2.plot(range(25, len(fc_predicted[i])), longs[i][25:], label='actuals'.format(i=1))
        ax2.legend(loc='best')
        ax3.plot(range(25, len(fc_predicted[i])), lat_predicted[i][25:], label='predictions'.format(i=2))
        ax3.plot(range(25, len(fc_predicted[i])), lats[i][25:], label='actuals'.format(i=1))
        ax3.legend(loc='best')
        ax4.plot(range(25, len(sog_predicted[i])), sog_predicted[i][25:], label='predictions'.format(i=2))
        ax4.plot(range(25, len(sog_predicted[i])), sogs[i][25:], label='actuals'.format(i=1))
        ax4.legend(loc='best')
        plt.show()
    plot(0)
    plot(1)
    print("done")

if __name__ == "__main__":
    main()